%        File: Resumen.tex
%     Created: Sat Sep 02 11:00 PM 2023 -0
% Last Change: Sat Sep 02 11:00 PM 2023 -0
%
\documentclass[a4paper]{article}
\begin{document}

\section{Modelos de simulacion de sistemas discretos}
\subsection{Simulacion}
Es una imitacion simplificada de un sistema que tiene por objetivo entender
y mejorar el sistema. 
Para estudiar un sistema real se construye un modelo de simulacion, este modelo 
se compone de un conjunto de suposiciones y simplificaciones del funcionamiento 
del sistema.
Entre las simulaciones pueden distinguirse
las estaticas, que son invariantes en el tiempo y las dinamicas, que imitan
al sistema y su comportamiento segun el avance del tiempo.

\subsection{Sistema} 
Es un conjunto de partes relacionadas entre si que operan de forma 
organizada para alcanzar un proposito.
Los sistemas se ven afectados por cambios que ocurren fuera de ellos,
en el entorno del sistema. Dependiendo del proposito del modelo que 
se este diseñando, debe elegirse una frontera que separe al sistema de
su entorno.
Pueden distinguirse las siguientes clases de sistema:
\begin{itemize}
    \item Naturales: Tienen origen en la naturaleza. Ejemplo: Atomo.
    \item Diseñados y fisicos: Son diseñados por el hombre. Ejemplo: auto.
    \item Diseñados y abstractos: Sistemas abstractos diseñados por el
        hombre. Ejemplo: matematicas.
    \item De actividad humana: Un sistema que tiene origen en la actividad
        humana pero no fue diseñado. Ejemplo: familia, ciudad.
\end{itemize}

\subsection*{Componentes de un sistema}
\begin{itemize}
    \item Entidades: objetos que son de interes para el modelo
    \item Atributos: propiedades de las entidades
    \item Actividad: representacion de un periodo de tiempo en el que ocurre un
    proceso relevante al sistema
    \item Estado: conjunto de variables necesarias para describir al Sistema
    en cualquier momento
    \item Evento: un suceso instantaneo que puede cambiar el estado del sistema
\end{itemize}

\subsection*{Tipos de sistema}
\begin{itemize}
    \item Sistemas discretos: son aquellos en los que el estado cambia solo 
    en determinados puntos discretos en el tiempo, solo en determinados eventos.
    Por lo tanto el estado del sistema es constante entre estos puntos.
    \item Sistemas continuos: su estado varia de forma continua, si se toma un 
    intervalo aleatoriamente pequeño de tiempo puede observarse un cambio en el 
    estado.
\end{itemize}
\subsection{Proposito de una simulacion}
El proposito de hacer una simulacion es obtener un mejor entendimiento e
identificar posibles mejoras para un sistema, esta informacion luego puede
ser utilizada para tomar mejores decisiones sobre el sistema real.

\subsection{La naturaleza de los sistemas de operacion}
Las simulaciones consideradas se usan principalmente para describir
sistemas fisicos diseñados y para sistemas de actividad humana.
Existen muchos sistemas que no pertencen exclusivamente a una de estas
categorias sino que incluyen partes de ambas. Se denomina de forma general
a estos sistemas como sistemas operacionales. Un sistema operacional es
una configuracion de recursos combinados para proveer un bien o servicio.

Estos sistemas pueden estar afectados por la \textbf{variabilidad}. Esta 
variabilidad puede ser predecible, por ejemplo el cambio de la cantidad
de operadores en un callcenter como respuesta a diferentes volumenes de 
llamadas durante un dia o impredecible, como la tasa de ingresos a una
sala de emergencias de un hospital.

Otra de sus caracteristicas es la \textbf{interconexion}. Los componentes
se afectan unos a otros. Considerando tambien la variabilidad presente
en el sistema, la prediccion del efecto de la interconexion es dificil
de llevar a cabo.

Por otro lado, los sistemas operacionales pueden tener cierta complejidad.
La complejidad puede ser combinatorial, es decir que al aumentar la
cantidad de partes del sistema, la candidad de conexiones entre ellas
aumenta rapidamente.
El otro tipo de complejidad es la dinamica. Esta complejidad surge de
la interaccion de componentes del sistema a traves del paso del tiempo,
lo que produce que una accion tenga efectos muy diferentes en el corto y
largo plazo, que una accion tenga diferentes consecuencias en las diferentes
partes del sistema y que las acciones produzcan efectos contraintuitivos.

La complejidad hace que sea muy dificil predecir el desempeño del sistema
al llevar a cabo acciones.

Es por estas caracteristicas de los sistemas operacionales que puede ser
util emplear simulaciones, ya que estas tienen la capacidad de representar
la variabilidad, interconexion y complejidad.

\subsection*{Requerimientos de la simulacion}
\begin{itemize}
    \item Validez: Que el modelo represente de manera adecuada al sistema real,
    condiderando el objetivo propuesto
    \item Credibilidad: Que los clientes confien en el sistema, confien en su 
    validez y esten dispuestos a utilizarlo para la toma de decisiones
    \item Utilidad: Que el modelo sea facil de usar y rapido para ejecutar los 
    escenarios
    \item Viabilidad: Que el modelo se pueda construir de acuerdo a las restricciones
    de tiempo, dinero, personal disponible, etc.
    \item Simplicidad: El modelo debe ser lo mas simple posible pero cumplir todos los 
    objetivos propuestos
\end{itemize}


\section*{Pasos de un proyecto de simulacion}

\subsection*{Formulacion del problema}
Cada estudio comienza con la formulacion de un problema que debe ser acordada
y comprendida tanto por quien desarrolla la simulacion como por quienes van 
a utilizar los resultados par tomar decisiones.

\subsection*{Fijar objetivos y plan de proyecto}
En base al problema definido en el paso anterior se determina cuales son las 
preguntas a responder y, si se decide que se va a desarrollar una simulacion,
se planifica el estudio (tiempo necesario, personal, costo, etc).

\subsection*{Desarrollo del modelo conceptual}
Debe tenerse en cuenta los objetivos planteados. Se hace una abstraccion del 
sistema real para obtener un modelo simple y luego se le agrega la complejidad 
necesaria para que sea util para alcanzar los objetivos.
Incluye entradas, salidas, objetivos, los componentes del sistema, las suposiciones
y simplificaciones. En esta etapa se definen que partes del sistema incluir y cuales 
no y tambien con que nivel de detalle se van a incluir en el modelo.
Las suposiciones se relacionan al conocimiento que se tiene del sistema real y se 
emplean para completar la informacion que se tiene. Las simplificaciones se 
emplean al abtraer el sistema a un modelo y es informacion que se decide no incluir
porque se considera que no es lo suficientemente relevante para los objetivos de la simulacion.
Ademas, el modelo conceptual tiene asociados los siguientes artefactos:

\begin{itemize}
    \item Descripcion del problema: Es una descripcion del problema y de todos los elementos del sistema real 
    que estan relacionados a el. Construir esta descripcion implica desarrollar un entendimiento del problema.
    Para lograr esto es importante enunciar el problema, crear diagramas que provean una vista estatica como 
    dinamica del sistema en estudio y complementar este entendimiento con supocisiones.
    \item Modelo de diseño: Es el diseño de los elementos y la logica que se utilizara para construir 
    el modelo computacional.
    \item Modelo computacional: Es la representacion en software del modelo conceptual.
\end{itemize}

\subsubsection*{Partes del modelo conceptual}
\begin{itemize}
    \item Objetivo: proposito del modelo de simulacion
    \item Salidas: resultados esperados de las corridas que deben permitir evaluar el objetivos
    \item Entradas: es un elemento de los definidos en la estructura o reglas de negocio que permiten
    generar una mejora o proveer conocimiento sobre el sistema real
    \item Factor experimental: es una entrada que define un elemento que puede ser modificado para afectar 
    al sistema
    \item Parametro: entrada que define un elemento fijo que configura a la simulacion para que logre imitar 
    al sistema real, no puede cambiar en los distintos experimentos
\end{itemize}

\subsection*{Recoleccion de datos}
Los datos necesarios para llevar a cabo la traduccion, considerando el modelo conceptual diseñado.

\subsection*{Traduccion al modelo computacional}
Se emplean el modelo conceptual y los datos recolectados para construir un modelo computacional.

\subsection*{Verificacion}
Si el modelo conceptual ha sido implementado correctamente en el modelo computacional y este ha sido
probado, es decir, funciona correctamente, se procede con la validacion. Si no pasa la verificacion, 
se regresa al paso anterior o se corrigen los errores en el modelo traducido.

\subsection*{Validacion}
Si el modelo propuesto representa de forma adecuada al sistema real se procede al diseño de experimentos,
mientras que si falla la validacion se debe regresar al paso de definir el modelo conceptual y recopilar 
nuevos datos.

\subsection*{Diseño de experimentos}
Se plantean los diseños experimentales a llevar a cabo, las distintas corridas que se van a hacer 
con el modelo computacional.

\subsection*{Corridas de produccion}
Son las corridas y su analisis que permiten estimar las 'medidas de performance' o las variables de 
respuesta del sistema real (?) para las configuraciones de parametros simuladas.
Si se considera que son necesarias mas corridas se pueden agregar a los diseños ya planteados o volver 
a la etapa anterior para agregar otro diseño.

\subsection*{Documentacion y reporte}
Una vez que se han terminado las corridas propuestas en el diseño de experimentos y se considera que no
es necesario realizar mas, se lleva a cabo la documentacion del proyecto de simulacion y un reporte.


\section*{Simulacion basada en eventos discretos}
El sistema se representa como entidades que fluyen de una actividad a otra.
El estado del modelo cambia de forma instantanea en momentos separados del 
tiempo, en estos momentos ocurre un evento, sin embargo, un evento no 
necesariamente cambia el estado del modelo.
Las entidades atraviesan procesos, sucesiones de eventos ordenadas que modifican
su estado.

\subsection*{Mecanismos de avance de tiempo orientado a intervalos}
El tiempo de la simulacion avanza en intervalos regulares y para cada intervalo 
se determina si un evento ocurrio en el. Si ocurrio un evento se lo ejecuta y 
se actualizan los valores de los estadisticos.
Tiene la desventaja de desperdiciar tiempo de procesamiento en cada intervalo 
vacio. Ademas, procesa los eventos que ocurrieron en un intervalo al final de este, 
lo que introduce errores. Esto se puede contraarrestar reduciendo el tamaño del 
intervalo con la desventaja de aumentar el procesamiento de intervalos vacios.


\subsection*{Mecanismos de avance de tiempo orientado a eventos}
El tiempo de la simulacion avanza la cantidad necesaria para alcanzar el proximo
evento programado. Requiere mantener una lista de eventos futuros que debe ser ordenada cada vez que 
se programa un nuevo evento.

\subsection*{Componentes}
\subsubsection*{Estado del sistema}
Coleccion de variables necesarias para describir al sistema en un punto del tiempo.

\subsubsection*{Reloj de simulacion}
Variable que mantiene el valor actual del tiempo simulado.

\subsubsection*{Lista de eventos}
Lista con el tiempo en el que ocurrira el proximo evento de cada tipo.

\subsubsection*{Contadores estadisticos}
Variables que contienen informacion sobre el funcionamiento del sistema,
son las salidas de la simulacion.

\subsubsection*{Rutina de inicializacion}
Programa que inicializa el modelo en el tiempo inicial $t=0$.

\subsubsection*{Rutina de tiempo}
Programa que actualiza el reloj de la simulacion basandose en la lista de 
eventos y determina el proximo tipo de evento.

\subsubsection*{Rutina de evento}
Programa que actualiza el estado del sistema cuando ocurre un evento. Para cada 
tipo de evento existe una rutina diferente. En la etapa de construccion del 
modelo de diseño es importante diferenciar entre eventos condicionales e 
incondicionales ya que solo estos ultimos tendran una rutina asociada. 
Los eventos condicionales tendran su logica modelada dentro de la rutina de 
evento de un evento del que dependan.
Se dice que un evento es condicional si su ocurrencia depende del estado o un 
componente del sistema.
Ademas, en la etapa de diseño debe considerarse que las rutinas de eventos son las 
que van a programar otros eventos a futuro y por lo tanto van a determinar el tiempo 
en que van a ocurrir.

\subsubsection*{Libreria de rutinas}
Libreria de programas utilizados para generar observaciones aleatorias a partir 
de las distribuciones de probabilidad asociadas al sistema. Las rutinas son 
empleadas por las rutinas de eventos.

\subsubsection*{Generador de reportes}
Programa que calcula las estimaciones de las medidas de performance %(?) -> cual es la definicion de medida de performance
a partir de los contadores estadisticos.

\subsubsection*{Programa principal}
Programa que ejecuta la rutina de inicializacion y la rutina de tiempo para luego 
transferir el control a las rutinas de evento correspondientes. Tambien tiene la 
funcion de evaluar la condicion de terminacion y de invocar al generador de reportes.


\section*{Recopilacion y analisis de datos}
Se pueden distinguir tres tipos de requerimientos de datos. El primer tipo son 
los datos preliminares o de contexto, estos se emplean para desarrollar un 
entendimiento del sistema a modelar y se veran reflejados luego en el modelo 
conceptual.
El segundo tipo es el de datos necesarios para construir el modelo computacional.
En esta etapa se requieren conjuntos mas grandes de datos mas detallados que 
permitan definir las distribuciones de tiempo y otros patrones en el modelo.
Por ultimo se requieren datos para validar el modelo generado.
Esta informacion puede obtenerse de comparar al modelo con el sistema real,
si este existe.

\subsection*{Obtencion}
Dependiendo de la disponibilidad de los datos se definen tres categorias.
La primera abarca los datos que ya estan disponibles o que ya se conocen, 
pueden provenir de una recopilacion anterior, de dispositivos que registren
datos de forma automatica u otras fuentes. Es necesario controlar que 
los datos tengan el formato adecuado y sean correctos antes de emplearlos.

La categoria B incluye los datos que no se conocen pero pueden recopilarse.

Por ultimo en la categoria C se encuentran los datos que no estan disponibles 
para su recopilacion, que no pueden obtenerse.
Para emplear datos de esta categoria existen algunas opciones:
\subsubsection*{Estimar los datos}
\begin{itemize}
    \item Utilizando sistemas similares
    \item Datos estandarizados
    \item Consultando expertos en el area 
    \item Proponiendo una aproximacion propia del equipo de simulacion (adivinar)
\end{itemize}
Estimar los datos añade incertidumbre a la simulacion por lo que deben aclararse
las estimaciones que se usaron y debe hacerse un estudio de sensibilidad, debe 
medirse el efecto de los datos estimados sobre los resultados. Si los efectos son
importantes, no sera util usar una estimacion.

\subsubsection*{Tomarlos como factores experimentales}
Deben ser datos de los que se tenga el control para modificarlos en el
sistema real
Si no es posible resolver el problema de los datos de categoria C de estas formas,
puede revisarse el modelo conceptual o modificarse los objetivos de la simulacion.
De esta forma pueden dejar de requerirse los datos que no se pueden obtener.

\subsubsection*{Datos de categoria A y B}
Si se tienen datos disponibles o si se desea recopilar datos, es fundamental que
se analicen las fuentes de informacion, en el caso de categoria A, debe considerarse
como fueron obtenidos los datos y para que fin. En ambas categorias, ademas, debe
verificarse que la informacion se encuentra en un formato adecuado a la simulacion.

\subsubsection*{Trazas}
Son conjuntos de datos que describen una secuencia de eventos y los tiempos en que 
sucedieron. Usualmente se recopilan del sistema real y luego la simulacion lee 
los eventos de esta secuencia para recrearlos. Son utiles para validar el modelo 
ya que se usan datos historicos, reales.
Dependen de que exista el sistema real y que esten presentes los datos. Puede ser muy
costoso emplear trazas si existen muchas fuentes de variabilidad.

\subsubsection*{Distribuciones empiricas}
Contienen valores o rangos de valores y las frecuencias con las que ocurre cada valor o rango.
Se pueden obtener de las trazas.
Por lo general es conveniente utilizar tiempos entre eventos en vez de cantidades de eventos por
unidad de tiempo ya que en la simulacion se desea recrear cada evento.

\subsubsection*{Distribuciones estadisticas}
Son distribuciones definidas por funciones matematicas. Pueden ser discretas o continuas.
Si se emplean estas distribuciones pueden llevarse a cabo un analisis de sensibilidad 
facilmente. Tienen la desventaja de poseer colas muy largas, es decir de poder generar
valores extremos muy grandes ocasionalmente y en algunos casos valores negativos.
No son transparentes para los clientes y no ayudan a generar confiabilidad en el modelo.

\subsubsection*{Seleccion de una distribucion estadistica}
Puede hacerse esta seleccion en base a las propiedades del proceso que se esta modelando.
Esto permite ahorrarse la recoleccion de datos.
Por otro lado, puede ajustarse una distribucion a los datos que se tienen, esto conlleva 
seleccionar una distribucion candidata, determinar los valores de sus parametros y analizar
la 'bondad' del ajuste, es decir, si la distribucion propuesta se parece a los datos recopilados.

Para seleccionar una candidata, se utiliza el histograma de frecuencias de los datos y se lo 
inspecciona para determinar a que distribucion se parece, ademas se deben considerar las propiedades 
del proceso.

Los parametros se calculan en base a los datos del histograma.
La \textbf{bondad de ajuste} puede probarse graficamente, por ejemplo construyendo un histograma basado en la
distribucion propuesta y comparandolo al original o haciendo una comparacion quantil-quantil entre ambos
conjuntos de datos.

\subsection*{Q-Q, cuantil cuantil}
Este metodo grafico es mas flexible que los analiticos ya que permite comparar pares de muestras muy diferentes, no es necesario que 
los tamaños sean iguales y se pueden testear muchos aspectos de las distribuciones al mismo tiempo por observar el grafico.
Es por esto que este metodo es mas util para determinar la naturaleza de las diferencias entre las distribuciones
que los metodos analiticos o estadisticos.

Por otro lado, puede hacerse la prueba por metodos analiticos como chi-cuadrado, Kolmogorov-Smirnov o Anderson-Darling.
\subsubsection*{Chi-cuadrado}
Formaliza la idea de comparar el histograma de la muestra con el de la distribucion a la que se quiere ajustar.
Requiere una muestra de gran tamaño y agrupar los valores en clases de equivalencia, estas clases se crean de forma 
arbitraria y depende cuales se designen, el resultado de la prueba puede variar. Ademas, es necesario agrupar clases
con muy poca frecuencia hasta llegar a un minimo.
Esta prueba es mas eficaz para probar distribuciones discretas, en el caso de distribuciones continuas sirve de 
aproximacion.

\subsubsection*{Kolmogorov-Smirnov}
Formaliza la idea de hacer un analisis grafico quantil-quantil.
Es util en casos de muestras reducidas y de no disponerse de parametros calculados sobre la muestra.
Tiene la ventaja de ser un test no parametrico, lo que significa que no es necesario calcular ningun 
parametro estadistico de la muestra.


\subsubsection*{Anderson-Darling}
Similar a K-S ya que se comparan las frecuencias acumuladas de la muestra y de la distribucion para llevar a cabo
la prueba. Esta prueba ademas considera la dispersion de los datos de la muestra. Por otro lado, este test utiliza 
otro metodo para medir las diferencias entre ambas, diferente a tomar
la maxima diferencia. Esto permite hacer a este test mas sensible y preciso, principalmente en las colas de las 
distribuciones.
Es uno de los metodos mas utiles para hacer pruebas de ajuste con distribucion normal, es mas preciso que K-S, 
pero requiere estimar parametros de la distribucion para poder hacer el test.

\section*{Montecarlo}
Una simulacion de montecarlo es un modelo estatico que representa el estado de un sistema en un determinado momento.
Los pasos para llevar a cabo una simulacion de montecarlo son:
\begin{itemize}
    \item Diseñar el modelo logico
    \item Especificar las distribuciones de probabilidad para las variables relevantes
    \item Incluir las dependencias entre variables
    \item Muestrear valores para las variables aleatorias utilizando las distribuciones
    \item Calcular el resultado del modelo segun los valores del muestreo y las dependencias
    \item Repetir el proceso hasta tener una muestra de resultados representativa
    \item Obtener la distribucion de probabilidad y los parametros estadisticos de la muestra de resultados
\end{itemize}

\section{Generacion de numeros aleatorios} 
Los numeros aleatorios deben ser uniformes e independientes. Deben ser muestras independientes una
de la otra de una distribucion uniforme entre 0 y 1.
Estas dos caracteristicas se pueden probar, la uniformidad mediante pruebas de bondad que comparen una muestra o
secuencia con una distribucion uniforme y la independencia comparando la correlacion entre valores de la muestra y 
la correlacion esperada que es 0.

\subsection*{Metodos de generacion de numeros pseudo-aleatorios}
Los metodos de generacion de numeros aleatorios deben poseer las siguientes caracteristicas:
\begin{itemize}
    \item El metodo debe ser rapido
    \item Portable a diferentes plataformas
    \item Debe tener un ciclo largo, haciendo referencia a la cantidad de numeros generados antes de repetir una 
    secuencia
    \item Debe aproximar las caracteristicas de los numeros aleatorios, incluyendo parametros como la varianza
\end{itemize}

\subsection*{Cuadrados medios}
Consiste en emplear los digitos centrales de cada numero, se obtiene el siguiente numero elevando al cuadrado
el anterior. El ciclo de este metodo y las caracteristicas de los numeros generados dependen de la eleccion de 
la semilla.

\subsubsection*{Congruencia lineal} 
Permite determinar el ciclo maximo y la velocidad de generacion al elegir los valores de a, c y m.

\section{Generacion de variables aleatorias}
Se utilizan numeros aleatorios para muestrear valores que pertenezcan a una determinada distribucion de
probabilidad de interes.

\subsection*{Metodo de la transformada inversa}
Consiste en hallar la funcion de probabilidad acumulada de la distribucion $F(X)$, luego igualarla a $R$,
un numero aleatorio que va a ser generado y luego despejar $X$ para obtener una funcion inversa $F^{-1}(R) = X$.
Con esta funcion se pueden obtener valores de la variable X a partir de los numeros R que sigan la distribucion 
empleada. 
Este metodo se utiliza cuando es posible y sencillo despejar la funcion inversa. Tambien se emplea para distribuciones
empiricas.
En el caso de distribuciones discretas se emplean los valores de la tabla de frecuencias acumuladas para determinar 
los extremos del subintervalo de $[0,1]$ que corresponde a cada valor discreto. Luego, dependiendo de a que subintervalo
pertenezca cada numero aleatorio, se calcula el valor de la variable.

\subsection*{Metodo del rechazo}
Para cada valor de variable aleatoria que se requiera, se genera un numero aleatorio. Se compara este numero a una condicion
y si la satisface, el valor se acepta como valor de la variable, por otro lado, si no cumple la condicion, se lo rechaza y
se genera un nuevo numero aleatorio para comenzar el proceso nuevamente. Dependiendo de la distribucion se empleara una 
condicion diferente o se empleara mas de un numero aleatorio por iteracion. Ademas, el numero aleatorio debe ser utilizado 
en alguna funcion que de como resultado la variable.
Este metodo permite generar variables de una distribucion de Poisson.

\subsection*{Metodos de propiedades especiales (Distribucion Normal)}
Existen metodos que no son generales sino que son caracteristicos de cada distribucion y se emplean para obtener valores 
de variables con distribuciones mas complejas o que son dificiles de obtener con los demas metodos.
Este es el caso de la distribucion normal. Para el caso de la distribucion normal, puede aproximarse mediante la suma
de $k$ numeros aleatorios. Con los numeros aleatorios se construye la distribucion normal estandar, considerando la media 
y varianza de los numeros, y luego se multiplica al resultado obtenido (al muestreo que se hizo) por la varianza deseada y
se le suma la media de la distribucion que se desea obtener. Este metodo sera mas preciso a medida que se aumenta la 
cantidad de numeros empleados pero esto tambien aumentara el costo de generar las variables.

\section*{Diseño de experimentos}
Se plantean interrogantes y se diseñan experimentos para determinar que pruebas es necesario hacer y como llevarlas a cabo para responder
a los interrogantes empleando la menor cantidad de recursos y tiempo posibles.

\subsection*{Experimento}
Es un cambio que se hace sobre las condiciones o las entradas de un sistema o proceso con el fin de medir el efecto del cambio sobre 
sus propiedades o variables de respuesta.

\subsection*{Unidad experimental}
Es la pieza o muestra sobre la que se realiza el experimento, debe ser representativa del sistema o proceso.

\subsection*{Variable de respuesta}
Son propiedades o caracteristicas que permiten conocer los efectos de los experimentos a partir de su medicion.

\subsection*{Factor}
Es una variable o caracteristica que se puede controlar o cambiar y por lo tanto son las variables que se emplean 
en los experimentos. Para elegir que factores emplear se debe recurrir al conocimiento que se tenga sobre el 
sistema en estudio, es decir, los factores que se estime que puedan influir en las respuestas.

\subsection*{Nivel}
Es un valor determinado que se asigna a un factor dentro de un experimento. Si el experimento involucra varios factores,
a una combinacion de niveles se le llama \textbf{tratamiento}.

\subsection*{Error aleatorio}
Es la parte de la variabilidad que se observa en las variables de respuesta que no se debe a los cambios de los 
experimentos sino que son errores naturales del proceso en estudio, son aleatorios. Pueden provenir de factores
que no fueron tenidos en cuenta por considerarse de poca importancia.

\subsection*{Error experimental}
Es el error que comete el experimentador al llevar a cabo los experimentos, si es importante el error no se podra
determinar el efecto de los factores en el sistema.

\subsection*{Diseño}
Es el numero de experimentos, sus tratamientos y la cantidad de repeticiones por cada uno.

\subsection*{Interacciones}
Dependiendo del diseño de experimento que se emplee, pueden existir interacciones entre los factores que tengan 
un efecto sobre las variables de respuesta ademas de los efectos individuales de los factores.

\subsection*{Planeacion}
En primer lugar se define el objeto de estudio, un problema si lo hay y se hace una investigacion preliminar para
conocer el dominio.
Luego se eligen las variables de respuesta que mejor caractericen al problema y que se puedan medir de forma
precisa y consistente.
Se determinan los factores y sus niveles

\subsection*{Analisis}
Ya que los experimentos se hacen sobre muestras y no la poblacion, debe hacerse un analisis estadistico para
determinar si los efectos de los factores son lo suficientemente grandes para garantizar que tambien se dan los 
efectos en la poblacion. Para esto se emplean los ANOVAs.

\subsection*{Interpretacion}
Se contrastan las conjeturas o conocimientos preliminares sobre el problema con los resultados de los experimentos.

\subsection*{Conclusion}
Se proponen medidas a implementar para solucionar el problema o mejorar el funcionamiento del sistema.

\subsection*{Principios del diseño de experimentos}
Si no se siguen estos principios, la validez de los datos que se obtengan de los experimentos sera perjudicada.

\subsubsection*{Aleatorizacion}
Las diferentes corridas de experimentos y la seleccion de material para las pruebas deben hacerse de forma 
aleatoria con el fin de que los errores causados por factores ambientales o temporales se distribuyan de forma 
aleatoria en todas las pruebas y se aumente la independencia de las pruebas.

\subsubsection*{Repeticion}
Llevar a cabo cada experimento mas de una vez, es decir, ejecutar varias veces cada tratamiento de forma aleatoria 
contribuye a la distribucion de los errores de forma aleatoria y ademas permite medir y distinguir entre la variabilidad 
debida a los efectos de factores y la variabilidad de los errores aleatorios o experimentales.

\subsection*{Diseño unifactorial}
Se estudia el efecto de un unico factor y se considera que este y el error aleatorio son las unicas dos fuentes de
variabilidad.
Se consideran ademas 4 hipotesis:
\begin{itemize}
    \item La suma de todos los efectos del factor es 0
    \item La suma de todos los errores es 0
    \item Los errores son independientes y uniformemente distribuidos
    \item Los errores tienen una distribucion normal
\end{itemize}
Como primer analisis puede hacerse una asignacion de la variacion que consiste en calcular que porcentaje de 
la variacion total ocupa la variacion del factor, teniendo en cuenta que el resto del porcentaje lo ocupa 
la variacion del error.

\subsection*{ANOVA}
Es el analisis de varianza, es un analisis estadistico que permite determinar si el efecto de un factor es 
relevante o no comparandolo con el efecto del error aleatorio.
La hipotesis nula es que las medias de cada nivel del factor son iguales, la hipotesis alternativa es que 
al menos un par de medias son diferentes, en este ultimo caso, se considera que el factor tiene un efecto con 
importancia estadistica sobre la variable de respuesta. Esto significa que los cambios en el nivel del factor 
generan cambios significativos en la respuesta.
El metodo emplea sumas de cuadrados de los efectos (SSA, SSE), sus cuadrados medios (MSA, MSE) y se utiliza una 
variable de Fisher para relacionar las varianzas. Esta variable es la que se utiliza para determinar si se 
cumple la hipotesis nula, comparandola con una tabla.

\subsection*{Intervalos de confianza}
Se utilizan intervalos de confianza como indicadores del grado de variabilidad de los efectos.
Se calculan con el cuadrado medio del error y la distribucion de Student. Si un intervalo 
contiene al valor cero, es probable que el efecto del nivel no sea relevante.
Tanto el ANOVA como los intervalos de confianza pueden ser calculados solo en diseños con
repeticiones ya que si no se hacen repeticiones no puede calcularse el error.

\subsection*{Diseño factorial completo}
Se emplea para conocer el efecto de mas de un factor y las interacciones entre ellos.
Tiene las mismas hipotesis que el diseño unifactorial y ademas:
\begin{itemize}
    \item La suma de los efectos de la interaccion de A y B en los niveles de A es 0
    \item La suma de los efectos de la interaccion de A y B en los niveles de B es 0
\end{itemize}

\subsection*{Diseño factorial $2^k$}
Consiste en un diseño con varios factores pero con solo dos niveles por factor. 
Se suele utilizar al comienzo e los experimentos o en situaciones donde realizar un 
diseño factorial completo puede ser muy costoso o complejo. Puede utilizarse para descartar 
factores que no tengan efectos sobre la variable de respuesta y luego considerar mas niveles 
en un diseño factorial completo.

\subsection*{Diseño factorial fraccionario $2^{k-p}$}
Se utiliza para estudiar el efecto en situaciones donde la cantidad de factores es demasiado
grande. 'P' es la candidad o fraccion de combinaciones de factores (o tratamientos) que se dejan sin estudiar 
en el diseño.
Se suele emplear en las primeras etapas de investigacion.
Las combinaciones que no se estudian son las que estan superpuestas o confundidas con otras 
combinaciones (sus efectos).
Utilizar este diseño implica dividir las $2^k$ combinaciones en $2^p$ particiones y ejecutar 
las corridas de simulacion en una de ellas para relacionar los resultados con las demas combinaciones.
La desventaja de crear muchas particiones es que se pierde mas informacion, por lo tanto debe 
tomarse una decision considerando el costo del diseño, la cantidad de factores y cuanta informacion 
es aceptable perder para simplificar el diseño.
Este diseño se basa en la jerarquizacion de factores: son mas importantes los efectos de factores 
individuales o principales que los efectos de las interacciones, que a su vez son mas relevantes que
las interacciones de mayores cantidades de factores.
Es conveniente utilizarlo cuando la cantidad de factores potencialmente irrelevantes, interacciones de 
varios factores, supere a la cantidad de factores principales y las interacciones dobles. Esto se da
para experimentos $2^5$ o mayores.
Ademas de la perdida de informacion, este diseño produce efectos alias, de los efectos que se pueden 
estimar con las corridas de la particion seleccionada, cada uno de ellos tendra al menos un alias. 
Dos efectos que son alias representan el mismo efecto.

\section*{Analisis de salidas}
Una salida de simulacion es una estimacion del desempeño del sistema y varian entre cada corrida de 
simulacion. Por lo tanto es necesario hacer un analisis de las salidas, para poder conocer el 
comportamiento del sistema real y para poder asi comparar distintos escenarios.
Si se llevan a cabo varias corridas de simulacion y se miden los valores para una variable de 
respuesta, se obtendra un estimador. La precision de este estimador puede medirse por el error 
estandar de la respuesta y por un intervalo de confianza.

\subsection*{Corridas}
Una corrida de simulacion es una ejecucion de un experimento predefinido que finaliza por tiempo o numero
de entidades simuladas. 
Para poder tener en cuenta los errores aleatorios es necesario que cada corrida tenga al menos dos 
repeticiones. Las repeticiones se hacen con el mismo modelo, parametros y criterios de fin de simulacion pero
con una semilla de generador de numeros aleatorios diferente.

\subsection*{Resultados}
Cada repeticion que se realiza produce un resultado. Estos resultados pueden ser discretos o continuos (
en vez de ser un conjunto de resultados es una funcion de resultado $Y(t)$).
Cada resultado tiene un punto de estimacion y un intervalo que representa el error en la estimacion del punto.
El punto de estimacion es la media de los resultados (valor medio para resultados continuos).
Luego, si se calcula la varianza de la muestra (el conjunto de resultados para una corrida), se puede determinar 
el intervalo de confianza. En el intervalo de confianza se asume que el resultado tiene una distribucion normal

\subsection*{Sistemas con final definido}
En un determinado momento no se programan mas eventos nuevos, por lo que al finalizar el procesamiento 
de los eventos ya programados, el periodo termina. Esto implica que hay un ultimo evento que marca el fin del
periodo. * Aca lo escribi como si fuese una simulacion, en realidad la definicion es para sistemas reales pero se 
entiende y aplica igual.
El estado del sistema al finalizar un periodo no debe alterar el siguiente.
Una alternativa son sistemas con periodos iguales, donde el periodo termina por tiempo, sin importar los eventos 
ya programados.

\subsection*{Sistemas con final no definido}
En estos sistemas los eventos nunca dejan de ocurrir por lo que si se quisiera dividir en periodos a las observaciones,
los periodos anteriores tendrian efecto sobre los posteriores.

\subsection*{Tipo de simulacion}
Al modelar el sistema, independientemente de su tipo, se creara un modelo que ejecute procesos con final definido.
Por otro lado, se las distingue en simulaciones terminantes y no terminantes respectivamente.
Las primeras finalizan al llegar a una condicion de vacio, al finalizar el periodo de investigacion o al 
emplear la totalidad de una traza, mientras que las no terminantes deben ser detenidas por un usuario.
Tambien se diferencian simulaciones en estacionarias o transientes. Las primeras son las que no experimentan 
grandes cambios en el estado del sistema o en las que las distribuciones de probabilidad de sus variables de 
estado no varian con el tiempo, aunque si puedan variar en cierto rango las salidas. Por lo general los sistemas
pasan por un estado inicial transiente, la puesta en marcha, y luego se estabilizan a un estado estacionario 
hasta finalizar sus procesos.

\subsection*{Criterios de salidas}
En el caso de estudiar el estado estacionario es interesante evaluar las salidas correspondientes a tiempos de corrida largos, 
mientras que al analizar el periodo o sistemas transientes son mas utiles las primeras observaciones y el momento en el que se 
alcanza el estado estacionario si lo hubiese.
Ademas, en el analisis del estado estacionario pueden diferenciarse tipos de ciclos, cada uno con diferentes comportamientos.
Si este es el caso, debe tenerse en cuenta a que ciclo pertenece cada salida.

\subsection*{Eliminar el estado transiente}
La simulacion debe minimizar el periodo de estado transiente para casos en los que este sea una puesta en marcha. Para esto puede 
realizarse corridas mas largas o asignarse las variables con valores cercanos a los del estado estacionario.

\section*{Verificacion y validacion}
La verificacion y validacion deben ser tenidas en cuenta a lo largo de todo el desarrollo de la simulacion 
ademas de llevarse a cabo al finalizar el desarrollo. 
La verificacion consiste en comparar el modelo computacional con el modelo conceptual para determinar si 
se ha implementado correctamente el sistema en el software de simulacion, si se han implementado correctamente las 
hipostesis que se tomaron sobre el sistema real.
La validacion consiste en determinar si el modelo que se ha diseñado representa correctamente al sistema 
real, determinar si las hipotesis sobre el sistema real son razonables. Es un proceso iterativo en el que se 
compara el comportamiento del sistema real con el modelo y 
se buscan discrepancias para poder corregir el modelo hasta alcanzar un nivel de precision aceptable.

\subsection*{Principios basicos}
\begin{itemize}
    \item Buen entendimiento del sistema
    \item Clara definicion de entidades y salidas
    \item Entendimiento de las necesidades u objetivos del clientes
    \item Consultar expertos a lo largo de todo el proceso
    \item Seguir el nivel de detalle propuesto
\end{itemize}

\subsection*{Verificacion}
Todas las tecnicas de verificacion y de validacion se basan en la deteccion y correccion de errores.
Algunas practicas de sentido comun que pueden llevarse a cabo para realizar la verificacion son:
\begin{itemize}
    \item Explicar el codigo a otras personas y comparar las formas de implementar el modelo
    \item Comparar salidas con distribuciones conocidas o con datos historicos
    \item Generar salidas de trazas: agregar a una lista cada evento que ocurre de forma ordenada 
    y con sus variables asociadas
    \item Hacer corridas con leves cambios en las entradas, si se observan grandes cambios en la 
    salida para minimos cambios de entrada se puede detectar un error
    \item Comparar salidas correspondientes a distintas configuraciones de entradas que en el sistema 
    real deberian producir las mismas salidas
    \item Que una persona diferente al desarrollador sea quien checkee el modelo computacional
    \item Diseñar un diagrama de flujo y seguir los caminos logicos para cada evento posible del sistema
    \item Verificar que las salidas del modelo computacional sean razonables para diferentes entradas
    \item Emplear las herramientas que provee el software de simulacion como lo son el controlador de 
    ejecucion y las interfaces graficas.
    \item Comparar metricas que puedan hacerse con modelos analiticos con las medidas del modelo computacional. 
    Aunque no sea posible conocer metricas analiticas o del sistema real para todos los parametros, una 
    respuesta incorrecta de cualquier variable indica un problema en la precision del modelo y una respuesta 
    correcta aporta confiabilidad de que tambien podra predecir correctamente las demas respuestas.
\end{itemize}

\subsection*{Validacion y calibracion}
Algunas tecnicas:
\begin{itemize}
    \item Presentar datos de mediciones reales y datos obtenidos de la simulacion a expertos en el dominio del problema
    para ver si pueden distinguirlos.
    \item Conocer investigaciones con objetivos similares
\end{itemize}


\end{document}


